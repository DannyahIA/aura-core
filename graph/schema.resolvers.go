package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"automation-hub/graph/model"
	"automation-hub/internal/domain"
	"context"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	appInput := convertGraphQLCreateTaskInputToApplication(input)
	task, err := r.TaskService.CreateTask(ctx, appInput)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, input model.UpdateTaskInput) (*model.Task, error) {
	appInput := convertGraphQLUpdateTaskInputToApplication(input)
	task, err := r.TaskService.UpdateTask(ctx, appInput)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	err := r.TaskService.DeleteTask(ctx, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ExecuteTask is the resolver for the executeTask field.
func (r *mutationResolver) ExecuteTask(ctx context.Context, id string) (*model.Task, error) {
	task, err := r.TaskService.ExecuteTask(ctx, id)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// CreateWorkflow is the resolver for the createWorkflow field.
func (r *mutationResolver) CreateWorkflow(ctx context.Context, input model.CreateWorkflowInput) (*model.Workflow, error) {
	appInput := convertGraphQLCreateWorkflowInputToApplication(input)
	workflow, err := r.WorkflowService.CreateWorkflow(ctx, appInput)
	if err != nil {
		return nil, err
	}

	// Get tasks for this workflow
	tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
	if err != nil {
		// Log error but continue with empty tasks
		tasks = []*domain.Task{}
	}

	return convertDomainWorkflowToGraphQL(workflow, tasks), nil
}

// ExecuteWorkflow is the resolver for the executeWorkflow field.
func (r *mutationResolver) ExecuteWorkflow(ctx context.Context, id string) (*model.Workflow, error) {
	workflow, err := r.WorkflowService.ExecuteWorkflow(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get tasks for this workflow
	tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
	if err != nil {
		// Log error but continue with empty tasks
		tasks = []*domain.Task{}
	}

	return convertDomainWorkflowToGraphQL(workflow, tasks), nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context) ([]*model.Task, error) {
	tasks, err := r.TaskService.GetAllTasks(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Task, len(tasks))
	for i, task := range tasks {
		result[i] = convertDomainTaskToGraphQL(task)
	}

	return result, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	task, err := r.TaskService.GetTask(ctx, id)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// Workflows is the resolver for the workflows field.
func (r *queryResolver) Workflows(ctx context.Context) ([]*model.Workflow, error) {
	workflows, err := r.WorkflowService.GetAllWorkflows(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Workflow, len(workflows))
	for i, workflow := range workflows {
		// Get tasks for this workflow
		tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
		if err != nil {
			// Log error but continue with empty tasks
			tasks = []*domain.Task{}
		}
		result[i] = convertDomainWorkflowToGraphQL(workflow, tasks)
	}

	return result, nil
}

// Workflow is the resolver for the workflow field.
func (r *queryResolver) Workflow(ctx context.Context, id string) (*model.Workflow, error) {
	workflow, err := r.WorkflowService.GetWorkflow(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get tasks for this workflow
	tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
	if err != nil {
		// Log error but continue with empty tasks
		tasks = []*domain.Task{}
	}

	return convertDomainWorkflowToGraphQL(workflow, tasks), nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// TaskStatusChanged is the resolver for the taskStatusChanged field.
func (r *subscriptionResolver) TaskStatusChanged(ctx context.Context, taskID *string) (<-chan *model.Task, error) {
	// For now, return a simple implementation
	// In a real implementation, this would connect to a pub/sub system
	ch := make(chan *model.Task)

	go func() {
		defer close(ch)
		// This is a placeholder - in a real implementation you would listen to events
		<-ctx.Done()
	}()

	return ch, nil
}

// WorkflowStatusChanged is the resolver for the workflowStatusChanged field.
func (r *subscriptionResolver) WorkflowStatusChanged(ctx context.Context, workflowID *string) (<-chan *model.Workflow, error) {
	// For now, return a simple implementation
	// In a real implementation, this would connect to a pub/sub system
	ch := make(chan *model.Workflow)

	go func() {
		defer close(ch)
		// This is a placeholder - in a real implementation you would listen to events
		<-ctx.Done()
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
