package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"automation-hub/graph/model"
	"automation-hub/internal/domain"
	"context"
	"fmt"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	appInput := convertGraphQLCreateTaskInputToApplication(input)
	task, err := r.TaskService.CreateTask(ctx, appInput)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, input model.UpdateTaskInput) (*model.Task, error) {
	appInput := convertGraphQLUpdateTaskInputToApplication(input)
	task, err := r.TaskService.UpdateTask(ctx, appInput)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	err := r.TaskService.DeleteTask(ctx, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ExecuteTask is the resolver for the executeTask field.
func (r *mutationResolver) ExecuteTask(ctx context.Context, id string) (*model.Task, error) {
	task, err := r.TaskService.ExecuteTask(ctx, id)
	if err != nil {
		return nil, err
	}

	return convertDomainTaskToGraphQL(task), nil
}

// CreateWorkflow is the resolver for the createWorkflow field.
func (r *mutationResolver) CreateWorkflow(ctx context.Context, input model.CreateWorkflowInput) (*model.Workflow, error) {
	appInput := convertGraphQLCreateWorkflowInputToApplication(input)
	workflow, err := r.WorkflowService.CreateWorkflow(ctx, appInput)
	if err != nil {
		return nil, err
	}

	// Get tasks for this workflow
	tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
	if err != nil {
		// Log error but continue with empty tasks
		tasks = []*domain.Task{}
	}

	return convertDomainWorkflowToGraphQL(workflow, tasks), nil
}

// ExecuteWorkflow is the resolver for the executeWorkflow field.
func (r *mutationResolver) ExecuteWorkflow(ctx context.Context, id string) (*model.Workflow, error) {
	workflow, err := r.WorkflowService.ExecuteWorkflow(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get tasks for this workflow
	tasks, err := r.WorkflowService.GetWorkflowTasks(ctx, workflow.ID)
	if err != nil {
		// Log error but continue with empty tasks
		tasks = []*domain.Task{}
	}

	return convertDomainWorkflowToGraphQL(workflow, tasks), nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context) ([]*model.Task, error) {
	tasks, err := r.TaskService.GetAllTasks(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Task, len(tasks))
	for i, task := range tasks {
		result[i] = convertDomainTaskToGraphQL(task)
	}

	return result, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, u := range users {
		phone := u.PhoneNumber
		created := u.CreatedAt.String()
		updated := u.UpdatedAt.String()
		result = append(result, &model.User{
			ID:          u.ID,
			Name:        u.Name,
			Email:       u.Email,
			PhoneNumber: &phone,
			CreatedAt:   &created,
			UpdatedAt:   &updated,
		})
	}
	return result, nil
}

// Banks is the resolver for the banks field.
func (r *queryResolver) Banks(ctx context.Context) ([]*model.Bank, error) {
	banks, err := r.BankRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.Bank
	for _, b := range banks {
		created := b.CreatedAt.String()
		updated := b.UpdatedAt.String()
		result = append(result, &model.Bank{
			ID:        b.ID,
			UserID:    b.UserID,
			Name:      b.Name,
			CreatedAt: &created,
			UpdatedAt: &updated,
		})
	}
	return result, nil
}

// BankAccounts is the resolver for the bankAccounts field.
func (r *queryResolver) BankAccounts(ctx context.Context) ([]*model.BankAccount, error) {
	accounts, err := r.BankAccountRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.BankAccount
	for _, a := range accounts {
		created := a.CreatedAt.String()
		updated := a.UpdatedAt.String()
		result = append(result, &model.BankAccount{
			ID:           a.ID,
			UserID:       a.UserID,
			BankID:       a.BankID,
			AccountID:    a.AccountID,
			Type:         a.Type,
			Balance:      a.Balance,
			CurrencyCode: a.CurrencyCode,
			CreatedAt:    &created,
			UpdatedAt:    &updated,
		})
	}
	return result, nil
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context) ([]*model.Transaction, error) {
	transactions, err := r.TransactionRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.Transaction
	for _, t := range transactions {
		transactionDate := t.TransactionDate.String()
		created := t.CreatedAt.String()
		updated := t.UpdatedAt.String()
		description := t.Description
		result = append(result, &model.Transaction{
			ID:              t.ID,
			BankID:          t.BankID,
			Type:            t.Type,
			Amount:          t.Amount,
			Currency:        t.Currency,
			Description:     &description,
			TransactionDate: &transactionDate,
			CreatedAt:       &created,
			UpdatedAt:       &updated,
		})
	}
	return result, nil
}

// BankData is the resolver for the bankData field.
func (r *queryResolver) BankData(ctx context.Context) ([]*model.BankData, error) {
	data, err := r.BankDataRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.BankData
	for _, d := range data {
		created := d.CreatedAt.String()
		updated := d.UpdatedAt.String()
		transferNumber := d.TransferNumber
		closingBalance := d.ClosingBalance
		automaticallyInvestedBalance := d.AutomaticallyInvestedBalance
		overdraftContractedLimit := d.OverdraftContractedLimit
		overdraftUsedLimit := d.OverdraftUsedLimit
		unarrangedOverdraftAmount := d.UnarrangedOverdraftAmount
		result = append(result, &model.BankData{
			ID:                           d.ID,
			BankAccountID:                d.BankAccountID,
			TransferNumber:               &transferNumber,
			ClosingBalance:               &closingBalance,
			AutomaticallyInvestedBalance: &automaticallyInvestedBalance,
			OverdraftContractedLimit:     &overdraftContractedLimit,
			OverdraftUsedLimit:           &overdraftUsedLimit,
			UnarrangedOverdraftAmount:    &unarrangedOverdraftAmount,
			CreatedAt:                    &created,
			UpdatedAt:                    &updated,
		})
	}
	return result, nil
}

// BankItems is the resolver for the bankItems field.
func (r *queryResolver) BankItems(ctx context.Context) ([]*model.BankItem, error) {
	items, err := r.BankItemRepo.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.BankItem
	for _, i := range items {
		created := i.CreatedAt.String()
		updated := i.UpdatedAt.String()
		status := i.Status
		executionStatus := i.ExecutionStatus
		result = append(result, &model.BankItem{
			ID:              i.ID,
			BankID:          i.BankID,
			Name:            i.Name,
			Status:          &status,
			ExecutionStatus: &executionStatus,
			CreatedAt:       &created,
			UpdatedAt:       &updated,
		})
	}
	return result, nil
	// ...fim do arquivo...
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: Products - products"))
}

// TaskStatusChanged is the resolver for the taskStatusChanged field.
func (r *subscriptionResolver) TaskStatusChanged(ctx context.Context, taskID *string) (<-chan *model.Task, error) {
	// For now, return a simple implementation
	// In a real implementation, this would connect to a pub/sub system
	ch := make(chan *model.Task)

	go func() {
		defer close(ch)
		// This is a placeholder - in a real implementation you would listen to events
		<-ctx.Done()
	}()

	return ch, nil
}

// WorkflowStatusChanged is the resolver for the workflowStatusChanged field.
func (r *subscriptionResolver) WorkflowStatusChanged(ctx context.Context, workflowID *string) (<-chan *model.Workflow, error) {
	// For now, return a simple implementation
	// In a real implementation, this would connect to a pub/sub system
	ch := make(chan *model.Workflow)

	go func() {
		defer close(ch)
		// This is a placeholder - in a real implementation you would listen to events
		<-ctx.Done()
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
